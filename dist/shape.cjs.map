{
  "version": 3,
  "sources": ["../src/shape.ts"],
  "sourcesContent": ["/**\n * @srhazi/shape: A handy way of asserting the shape of unknown values.\n */\n\nexport const version: string = LIB_VERSION;\n\n/**\n * Each AssertFn<T> is a function that proves an unknown value is of type T\n */\nexport type AssertFn<T> = (val: unknown) => val is T;\n\n/**\n * Turn an AssertFn<T> type into just T\n */\nexport type AssertFnType<V> = V extends AssertFn<infer A> ? A : never;\n\nexport const isString: AssertFn<string> = (val): val is string =>\n    typeof val === 'string';\n\nexport const isNumber: AssertFn<number> = (val): val is number =>\n    typeof val === 'number';\n\nexport const isBigint: AssertFn<bigint> = (val): val is bigint =>\n    typeof val === 'bigint';\n\nexport const isBoolean: AssertFn<boolean> = (val): val is boolean =>\n    typeof val === 'boolean';\n\nexport const isSymbol: AssertFn<symbol> = (val): val is symbol =>\n    typeof val === 'symbol';\n\nexport const isUndefined: AssertFn<undefined> = (val): val is undefined =>\n    val === undefined;\n\nexport const isUnknown: AssertFn<unknown> = (val): val is unknown => true;\n\nexport const isNull: AssertFn<null> = (val): val is null => val === null;\n\nexport const isArray: AssertFn<unknown[]> = (val): val is unknown[] =>\n    Array.isArray(val);\n\nexport const isFunction: AssertFn<() => unknown> = (\n    val\n): val is () => unknown => typeof val === 'function';\n\nexport function isTruthy<T>(val: T): val is Exclude<\n    T,\n    // all values are truthy except false, 0, -0, 0n, \"\", null, undefined, NaN, and document.all\n    0 | -0 | 0n | '' | null | undefined\n> {\n    return !!val;\n}\n\n/**\n * Produces a check that the value is exactly the constant provided.\n */\nexport function isExact<const T>(constant: T): (val: unknown) => val is T {\n    return isEnum(constant);\n}\n\n/**\n * Produces a check that the value is exactly the constant provided.\n */\nexport const is: typeof isExact = isExact;\n\n/**\n * Produces a check that the value is one of exactly the constants provided.\n */\nexport function isEnum<const T>(...values: T[]): (val: unknown) => val is T {\n    return (val: unknown): val is T => values.some((which) => which === val);\n}\n\n/**\n * Produces a check that satisfies one of the provided checks.\n */\nexport function isEither<X extends AssertFn<any>[]>(\n    ...checks: X\n): (val: unknown) => val is AssertFnType<X[number]> {\n    return (val: unknown): val is AssertFnType<X[number]> => {\n        return checks.some((check) => check(val));\n    };\n}\n\n/**\n * Produces a check that the value is an array of items that satisfy the provided checks.\n */\nexport function isArrayOf<T>(check: AssertFn<T>): (val: unknown) => val is T[] {\n    return (val: unknown): val is T[] => {\n        return Array.isArray(val) && val.every((item) => check(item));\n    };\n}\n\n/**\n * Produces a check that the value is an object whose keys all satisfy the provided check\n */\nexport function isRecordOf<T>(isThing: AssertFn<T>) {\n    return (record: unknown): record is Record<string, T> =>\n        !!(\n            typeof record === 'object' &&\n            record &&\n            !Array.isArray(record) &&\n            Object.values(record).every((value) => isThing(value))\n        );\n}\n\n/**\n * Produces a check that the value is an object whose entries (keys and values) all satisfy the provided check\n */\nexport function isRecordWith<K extends string | number | symbol, V>(\n    isEntry: AssertFn<[K, V]>\n) {\n    return (record: unknown): record is Record<K, V> =>\n        !!(\n            typeof record === 'object' &&\n            record &&\n            !Array.isArray(record) &&\n            Object.entries(record).every((entry) => isEntry(entry))\n        );\n}\n\n/**\n * Produces a check that the value is an object whose entries (keys and values) all satisfy the provided check\n */\nexport function isTuple<K, V>(isLeft: AssertFn<K>, isRight: AssertFn<V>) {\n    return (pair: unknown): pair is [K, V] =>\n        !!(\n            typeof pair === 'object' &&\n            pair &&\n            Array.isArray(pair) &&\n            pair.length === 2 &&\n            isLeft(pair[0]) &&\n            isRight(pair[1])\n        );\n}\n\n/**\n * Produces a check that the value is an object containing keys that map to checks.\n */\nexport function isShape<T extends Record<string, AssertFn<any>>>(\n    shape: T\n): AssertFn<{ [Key in keyof T]: AssertFnType<T[Key]> }> {\n    return (\n        val: unknown\n    ): val is { [Key in keyof T]: AssertFnType<T[Key]> } => {\n        if (typeof val !== 'object') {\n            return false;\n        }\n        if (!val) {\n            return false;\n        }\n        for (const [key, check] of Object.entries(shape)) {\n            if (!(key in val)) {\n                return false;\n            }\n            if (!check((val as Record<string, any>)[key])) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIO,IAAM,UAAkB;AAYxB,IAAM,WAA6B,CAAC,QACvC,OAAO,QAAQ;AAEZ,IAAM,WAA6B,CAAC,QACvC,OAAO,QAAQ;AAEZ,IAAM,WAA6B,CAAC,QACvC,OAAO,QAAQ;AAEZ,IAAM,YAA+B,CAAC,QACzC,OAAO,QAAQ;AAEZ,IAAM,WAA6B,CAAC,QACvC,OAAO,QAAQ;AAEZ,IAAM,cAAmC,CAAC,QAC7C,QAAQ;AAEL,IAAM,YAA+B,CAAC,QAAwB;AAE9D,IAAM,SAAyB,CAAC,QAAqB,QAAQ;AAE7D,IAAM,UAA+B,CAAC,QACzC,MAAM,QAAQ,GAAG;AAEd,IAAM,aAAsC,CAC/C,QACuB,OAAO,QAAQ;AAEnC,SAAS,SAAY,KAI1B;AACE,SAAO,CAAC,CAAC;AACb;AAKO,SAAS,QAAiB,UAAyC;AACtE,SAAO,OAAO,QAAQ;AAC1B;AAKO,IAAM,KAAqB;AAK3B,SAAS,UAAmB,QAAyC;AACxE,SAAO,CAAC,QAA2B,OAAO,KAAK,CAAC,UAAU,UAAU,GAAG;AAC3E;AAKO,SAAS,YACT,QAC6C;AAChD,SAAO,CAAC,QAAiD;AACrD,WAAO,OAAO,KAAK,CAAC,UAAU,MAAM,GAAG,CAAC;AAAA,EAC5C;AACJ;AAKO,SAAS,UAAa,OAAkD;AAC3E,SAAO,CAAC,QAA6B;AACjC,WAAO,MAAM,QAAQ,GAAG,KAAK,IAAI,MAAM,CAAC,SAAS,MAAM,IAAI,CAAC;AAAA,EAChE;AACJ;AAKO,SAAS,WAAc,SAAsB;AAChD,SAAO,CAAC,WACJ,CAAC,EACG,OAAO,WAAW,YAClB,UACA,CAAC,MAAM,QAAQ,MAAM,KACrB,OAAO,OAAO,MAAM,EAAE,MAAM,CAAC,UAAU,QAAQ,KAAK,CAAC;AAEjE;AAKO,SAAS,aACZ,SACF;AACE,SAAO,CAAC,WACJ,CAAC,EACG,OAAO,WAAW,YAClB,UACA,CAAC,MAAM,QAAQ,MAAM,KACrB,OAAO,QAAQ,MAAM,EAAE,MAAM,CAAC,UAAU,QAAQ,KAAK,CAAC;AAElE;AAKO,SAAS,QAAc,QAAqB,SAAsB;AACrE,SAAO,CAAC,SACJ,CAAC,EACG,OAAO,SAAS,YAChB,QACA,MAAM,QAAQ,IAAI,KAClB,KAAK,WAAW,KAChB,OAAO,KAAK,CAAC,CAAC,KACd,QAAQ,KAAK,CAAC,CAAC;AAE3B;AAKO,SAAS,QACZ,OACoD;AACpD,SAAO,CACH,QACoD;AACpD,QAAI,OAAO,QAAQ,UAAU;AACzB,aAAO;AAAA,IACX;AACA,QAAI,CAAC,KAAK;AACN,aAAO;AAAA,IACX;AACA,eAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,KAAK,GAAG;AAC9C,UAAI,EAAE,OAAO,MAAM;AACf,eAAO;AAAA,MACX;AACA,UAAI,CAAC,MAAO,IAA4B,GAAG,CAAC,GAAG;AAC3C,eAAO;AAAA,MACX;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AACJ;",
  "names": []
}
